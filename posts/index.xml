<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
    <channel>
        <title>Posts on Bryan Deagle</title>
        <link>https://dea.gl/posts/</link>
        <description>Recent content in Posts on Bryan Deagle</description>
        <generator>Hugo -- gohugo.io</generator>
        <language>en-us</language>
        <copyright>&lt;a href=&#34;https://creativecommons.org/licenses/by-nc/4.0/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;CC BY-NC 4.0&lt;/a&gt;</copyright>
        <lastBuildDate>Fri, 14 Aug 2020 00:00:00 +0000</lastBuildDate>
        <atom:link href="https://dea.gl/posts/index.xml" rel="self" type="application/rss+xml" />
        
        <item>
            <title>An Overview of HTTPS</title>
            <link>https://dea.gl/posts/2020/08/an-overview-of-https/</link>
            <pubDate>Fri, 14 Aug 2020 00:00:00 +0000</pubDate>
            
            <guid>https://dea.gl/posts/2020/08/an-overview-of-https/</guid>
            <description>How HTTPS Works Type facebook.com into your web browser, and you&amp;rsquo;ll see a little lock appear to the left of the URL. That lock means you are using HTTPS and signifies that your connection to facebook.com is secure.
Using HTTPS over the older, not secure, HTTP has two benefits:
 The website your browser is talking to has proven itself to be facebook.com and is not just pretending to be. The communications your browser sends to the website are encrypted so that no-one except your browser and the website can read them.</description>
            <content type="html"><![CDATA[<h2 id="how-https-works">How HTTPS Works</h2>
<p>Type facebook.com into your web browser, and you&rsquo;ll see a little lock appear to the left of the URL. That lock means you are using <em>HTTPS</em> and signifies that your connection to facebook.com is secure.</p>
<p>Using HTTPS over the older, not secure, HTTP has two benefits:</p>
<ol>
<li>The website your browser is talking to has proven itself to be facebook.com and is not just pretending to be.</li>
<li>The communications your browser sends to the website are encrypted so that no-one except your browser and the website can read them.</li>
</ol>
<p>Those communications can include usernames, passwords, credit card numbers, and other critical information you wouldn&rsquo;t want in the hands of anyone but the real facebook.com.</p>
<h2 id="ensuring-identity">Ensuring Identity</h2>
<p>Your browser trusts that the website truly is facebook.com because it has presented us with a <em>certificate</em> stating it is facebook.com. If you click the lock on your browser, you can view it yourself.</p>
<p>&ldquo;But why should you trust that certificate, you ask?&rdquo; Great question. Because, like real-world certificates, someone you should trust has signed it.</p>
<p>Inspecting facebook.com&rsquo;s certificate shows that DigiCert signed it.</p>
<p>&ldquo;Hold on. Who is DigiCert, and why should I trust them?&rdquo; you ask. Another great question. I like where your head&rsquo;s at.</p>
<p>Digicert is a <em>Certificate Authority</em>. That means they are an organization able to sign certificates to prove that they are valid.</p>
<p>I trust DigiCert because Microsoft trusts them, and because I run Windows, I have no choice but to trust Microsoft. Because Microsoft trusts DigiCert as a Certificate Authority, Windows trusts certificates signed by DigiCert.</p>
<p>You can view this information by searching for <strong>Manage computer certificates</strong> in your start menu. From there, click on <strong>Trusted Root Certification Authorities »  Certificates</strong>, and in that long list, you should see DigiCert.</p>
<p>Microsoft also publishes the list of Certificate Authorities <a href="https://ccadb-public.secure.force.com/microsoft/IncludedCACertificateReportForMSFT">here</a>. On that page, you can find DigiCert as well.</p>
<p>And so that&rsquo;s the chain of trust. You trust Microsoft because you run their operating system. Microsoft has said you can trust what DigiCert says. And finally, DigiCert has said, you can trust the server you&rsquo;re talking to is facebook.com.</p>
<p>You can rest easy knowing you&rsquo;re not sending private information to somebody pretending to be facebook.com.</p>
<h2 id="ensuring-privacy">Ensuring Privacy</h2>
<p>Even though that&rsquo;s the real facebook.com, who might be able to intercept those communications and read your private data? That&rsquo;s an easy enough question to answer. On Windows, open up a command prompt and type:</p>
<pre><code>tracert facebook.com
</code></pre><p>On Linux or Mac OS, type:</p>
<pre><code>traceroute facebook.com
</code></pre><p>That command displays all the intermediate servers your communications go through before making it to facebook.com. Each line is a different server, and the first line is likely your router.</p>
<p>Each item between your router and facebook.com is another server capable of reading all the unencrypted information you send to facebook.com. That can sometimes be dozens of servers that are not you, or facebook.com, in a position to read all communications between you and facebook.com.</p>
<h2 id="upgrading-to-https">Upgrading to HTTPS</h2>
<p>I hope you understand the value that HTTPS provides and the meaning behind that little lock symbol. There&rsquo;s really no downside to using HTTPS, so you should try to use it everywhere it&rsquo;s available.</p>
<p>How did it know to use HTTPS and not the regular old, unsafe HTTP when I typed in facebook.com?</p>
<p>Not all websites support HTTPS. So, when you type in facebook.com, your browser requested the HTTP version of facebook.com (<a href="http://facebook.com">http://facebook.com</a>). Facebook&rsquo;s servers then responded by redirecting you to the HTTPS version of the site (<a href="https://facebook.com">https://facebook.com</a>).</p>
<p>If you care to inspect the network traffic, you can see something like what&rsquo;s shown below. That&rsquo;s facebook telling your browser, &ldquo;We support HTTPS, and you&rsquo;re going to want to use that instead of regular old HTTP.&rdquo;</p>
<pre><code>General
  Request URL: http://facebook.com/
  Request Method: GET
  Status Code: 307 Internal Redirect
  Referrer Policy: no-referrer-when-downgrade
Response Headers:
  Location: https://facebook.com/
  Non-Authoritative-Reason: HSTS
...
</code></pre><p>That&rsquo;s very nice of Facebook to be looking out for my privacy and security. But we should be taking this into our own hands, and not depending on websites to upgrade us to HTTPS, and encrypt our communications.</p>
<p>Enter HTTPS Everywhere.</p>
<h2 id="https-everywhere">HTTPS Everywhere</h2>
<p><a href="https://www.eff.org/https-everywhere">HTTPS Everywhere</a> is a Firefox, Chrome, and Opera extension that encrypts your communications with many major websites, which makes your browsing more secure.</p>
<p>By using HTTPS Everywhere, you can rest easy knowing that your browser is doing everything it can, upgrade communications to HTTPS wherever possible, and not depend on websites themselves to secure communications.</p>
]]></content>
        </item>
        
        <item>
            <title>TLS/SSL Certificates</title>
            <link>https://dea.gl/posts/2020/08/tls/ssl-certificates/</link>
            <pubDate>Fri, 14 Aug 2020 00:00:00 +0000</pubDate>
            
            <guid>https://dea.gl/posts/2020/08/tls/ssl-certificates/</guid>
            <description></description>
            <content type="html"><![CDATA[]]></content>
        </item>
        
        <item>
            <title>Virtual Private Networks</title>
            <link>https://dea.gl/posts/2020/08/virtual-private-networks/</link>
            <pubDate>Fri, 14 Aug 2020 00:00:00 +0000</pubDate>
            
            <guid>https://dea.gl/posts/2020/08/virtual-private-networks/</guid>
            <description></description>
            <content type="html"><![CDATA[]]></content>
        </item>
        
        <item>
            <title></title>
            <link>https://dea.gl/posts/1/01/</link>
            <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
            
            <guid>https://dea.gl/posts/1/01/</guid>
            <description>Setting up a Man-in-the-Middle Getting a raspberry pi together Download the Raspberry Pi image from the official site
Securing the Raspberry pi Follow this article to secure your raspberry pi.
If you&amp;rsquo;ve installed ufw, you&amp;rsquo;ll want to allow HTTP and HTTPS.
ufw allow HTTPufw allow HTTPSInstalling MITM Proxy apt install mitmproxy</description>
            <content type="html"><![CDATA[<h1 id="setting-up-a-man-in-the-middle">Setting up a Man-in-the-Middle</h1>
<h2 id="getting-a-raspberry-pi-together">Getting a raspberry pi together</h2>
<p>Download the Raspberry Pi image from <a href="https://www.raspberrypi.org/downloads/">the official site</a></p>
<h2 id="securing-the-raspberry-pi">Securing the Raspberry pi</h2>
<p>Follow <a href="https://www.raspberrypi.org/documentation/configuration/security.md">this article</a> to secure your raspberry pi.</p>
<p>If you&rsquo;ve installed ufw, you&rsquo;ll want to allow HTTP and HTTPS.</p>
<pre><code>ufw allow HTTP
ufw allow HTTPS
</code></pre><h2 id="installing-mitm-proxy">Installing MITM Proxy</h2>
<pre><code>apt install mitmproxy
</code></pre>]]></content>
        </item>
        
        <item>
            <title></title>
            <link>https://dea.gl/posts/1/01/</link>
            <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
            
            <guid>https://dea.gl/posts/1/01/</guid>
            <description>Introduction In this article, I&amp;rsquo;ll discuss TLS/SSL certificates. To learn more than just the theory, I&amp;rsquo;ll be acting as my own Certificate Authority, which will allow me to generate all the required files for TLS/SSL communication.
What is SSL/TLS? SSL and TLS are both cryptographic protocols used to increase security by encrypting communication over computer networks. SSL stands for Secure Sockets Layer while TLS stands for Transport Layer Security. TLS is the successor of SSL 3.</description>
            <content type="html"><![CDATA[<h2 id="introduction">Introduction</h2>
<p>In this article, I&rsquo;ll discuss TLS/SSL certificates. To learn more than just the theory, I&rsquo;ll be acting as my own Certificate Authority, which will allow me to generate all the required files for TLS/SSL communication.</p>
<h2 id="what-is-ssltls">What is SSL/TLS?</h2>
<p>SSL and TLS are both cryptographic protocols used to increase security by encrypting communication over computer networks. SSL stands for <strong>Secure Sockets Layer</strong> while TLS stands for <strong>Transport Layer Security</strong>. TLS is the successor of SSL 3.0 and is now the standard (although both methods are still commonly referred to as SSL).</p>
<h2 id="becoming-a-certificate-authority">Becoming a Certificate Authority</h2>
<h3 id="step-1-generate-a-key">Step 1. Generate a key</h3>
<pre><code>openssl genrsa -des3 -out ca.key 2048
</code></pre><p>In this command, we&rsquo;re using the <strong>openssl</strong> tool to generate an RSA key (<strong>genrsa</strong>). With the <strong>-des3</strong> option, we&rsquo;re using the <a href="https://en.wikipedia.org/wiki/Triple_DES">triple DES</a> engine to encrypt the key. This option requires us to use a password whenever we want to use this key, which adds an essential layer of security.</p>
<p>We&rsquo;re telling the openssl tool to generate a key <strong>2048</strong> bits long, and output to <strong>ca.key</strong>.</p>
<h3 id="step-2-generate-a-root-certificate">Step 2. Generate a Root Certificate</h3>
<pre><code>openssl req -new -x509 -key ca.key -sha256 -days 365000 -out ca.pem
</code></pre><p>The <strong>openssl req</strong> command creates and processes certificate requests. It can also create self-signed certificates, which is what we&rsquo;re using it for, by giving it the <strong>-new -x509</strong> options.</p>
<p>We&rsquo;re using the <strong>sha256</strong> digest to sign this certificate with our previously generated key, <strong>ca.key</strong>.</p>
<p>We&rsquo;re also making this certificate valid for 1,000 years (365000 days) because it&rsquo;s self-signed, so expiry isn&rsquo;t too important.</p>
<p>Congratulations! You are now officially a <strong>Certificate Authority</strong>.</p>
<h2 id="getting-people-to-trust-your-authority">Getting People to Trust Your Authority</h2>
<p>Being a Certificate Authority doesn&rsquo;t mean much if nobody respects your authority.</p>
<p>The real Certificate Authorities will join, for example, <a href="https://docs.microsoft.com/en-us/security/trusted-root/program-requirements">Microsoft&rsquo;s Trusted Root Program</a> and have their certificates automatically installed on all Windows distributions.</p>
<p>Because we&rsquo;re just generating these for personal use, we&rsquo;ll have to manually install them on every device we want to trust us.</p>
<h3 id="1-installation-on-windows">1. Installation on Windows</h3>
<ul>
<li>Double-click on the <strong>certificate.crt</strong> file</li>
<li>Click on <strong>Install Certificate…</strong> then <strong>Current User</strong></li>
<li>Select <strong>Place all certificates in the following store</strong></li>
<li>Browse to <strong>Trusted Root Certificate Authorities</strong></li>
<li>Click <strong>Next</strong> and then click <strong>Finish</strong></li>
</ul>
<h3 id="2-installation-on-android">2. Installation on Android</h3>
<ul>
<li>Go to <strong>Settings</strong> » <strong>Security</strong> » <strong>Encryption &amp; credentials</strong></li>
<li>Go to <strong>Install from storage</strong> and select your certificate</li>
<li>Give the certificate a memorable name and select <strong>Wi-Fi</strong></li>
</ul>
<h3 id="3-installation-on-macos">3. Installation on MacOS</h3>
<ul>
<li>Open the macOS Keychain app, and go to <strong>File &gt; Import Items…</strong></li>
<li>Select your private key file, then search for the Common Name name</li>
<li>Double click on your certificate and expand the Trust section</li>
<li>Change <strong>When using this certificate</strong> to <strong>Always Trust</strong></li>
</ul>
<pre><code>sudo security add-trusted-cert -d -r trustRoot -k &quot;/Library/Keychains/System.keychain&quot; certificate.crt
</code></pre><h3 id="4-installation-on-ios">4. Installation on iOS</h3>
<ul>
<li>Go to <strong>Settings</strong> » <strong>Profile Downloaded</strong> » <strong>Install</strong></li>
<li>Go to <strong>Settings</strong> » <strong>General</strong> » <strong>About</strong></li>
<li>Scroll to the bottom and select <strong>Certificate Trust Settings</strong></li>
<li>Select <strong>Enable Full Trust for Root Certificates</strong></li>
</ul>
<h2 id="signing-certificates-as-a-certificate-authority">Signing Certificates as a Certificate Authority</h2>
<p>For SSL/TLS, web servers need two things:</p>
<ol>
<li>A private key, to encrypt traffic</li>
<li>A certificate, which serves as a public key and proof the webserver in question owns the domain.</li>
</ol>
<h3 id="step-1-generate-a-private-key">Step 1. Generate a Private Key</h3>
<p>It&rsquo;s helpful (but not necessary) to name the key, and all files we generate, based on the webserver we&rsquo;re running. In our example, we&rsquo;ll use <em>example.com</em>.</p>
<pre><code>openssl genrsa -out example.com.key 2048
</code></pre><p>This time we won&rsquo;t be password-protecting this key with the <strong>-des3</strong> option, like we did with our Root CA key.</p>
<h3 id="step-2-generate-a-certificate-signing-request">Step 2. Generate a Certificate Signing Request</h3>
<p>Even though we&rsquo;re the ones signing our certificate, in most situations, a different entity will be signing our certificate, so the workflow is:</p>
<ol>
<li>Generate a certificate signing request</li>
<li>Fulfill the certificate signing request with our ca private key</li>
</ol>
<p>We generate the certificate signing request (CSR) with the following command:</p>
<pre><code>openssl req -new -key example.com.key -out example.com.csr
</code></pre><p>We&rsquo;ll also need to configure the proper extensions for the certificate to work with most protocols. For that we&rsquo;ll create an extension config file, named example.com.ext, with the following contents:</p>
<pre><code>authorityKeyIdentifier=keyid
basicConstraints=CA:FALSE
keyUsage = digitalSignature, nonRepudiation, keyEncipherment, dataEncipherment
subjectAltName = @alt_names

[alt_names]
DNS.1 = example.com
</code></pre><h3 id="step-3-fulfill-the-certificate-signing-request">Step 3. Fulfill the Certificate Signing Request</h3>
<p>We fulfill our certificate signing process by generating our new certificate, signed with our Root Certificate Authority key.</p>
<pre><code>openssl x509 -req -in example.com.csr -CA ca.pem -CAkey ca.key -CAcreateserial -out example.com.crt -days 825 -sha256 -extfile example.com.ext
</code></pre><p>We should now have <strong>example.com.crt</strong> to go along with our <strong>example.com.key</strong>, which is all we need to enable TLS/SSL on our website. Below is an example of an Apache configuration that utilizes our newly generated certificate and key.</p>
<pre><code>&lt;VirtualHost *:80&gt;
        ServerName example.com
        ...
&lt;/VirtualHost&gt;

&lt;VirtualHost *:443&gt;
        ServerName example.com
        ...
        SSLCertificateFile /opt/cert/example.com.crt
        SSLCertificateKeyFile /opt/cert/example.com.key
&lt;/VirtualHost&gt;
</code></pre>]]></content>
        </item>
        
    </channel>
</rss>
